use super::ast::*;
use self::Operator::*;
use self::ExprType::*;

pub class_file -> ClassFile<'input> =
    _ imports:import*
    _ class:class_def
    _ !.
    { ClassFile { imports, class } }

// ####################################
// ## USING DECLARATION
// ####################################

import -> Using<'input> =
    _ "use" _ using:import_def ";" { using }

import_def -> Using<'input> =
    _ name:id _ alias:import_alias? _ { Using::Module(name, alias) }   /
    _ name:id _ specs:import_specifics _ { Using::Include(name, specs) }

import_alias -> &'input str =
    _ "as" _ alias:id _ { alias }

import_specifics -> Vec<Using<'input>> =
    _ "{" specs:(import_def ++ ",") "}" { specs }

// ####################################
// ## CLASS DECLARATION
// ####################################

class_def -> ClassDef<'input> =
    _ access:access_modifiers
    _ ctype:class_type
    _ "{"
    _ fields:class_field*
    _ methods:func_def*
    _ "}"
    { ClassDef { access, ctype, fields, methods } }
    
class_type -> ClassType<'input> =
    _ "enum" _ ty:class_typing { ClassType::Enum(ty.0, ty.2) }           /
    _ "trait" _ ty:class_typing { ClassType::Trait(ty.0, ty.1, ty.2) }   /
    _ "struct" _ ty:class_typing { ClassType::Struct(ty.0, ty.1, ty.2) }

class_typing -> (Type<'input>, Vec<Type<'input>>, Vec<TypeGuard<'input>>) =
    _ ty:type_def
    _ inherits:class_inherits?
    _ guards:type_guards?
    { (ty, inherits.unwrap_or(Vec::new()), guards.unwrap_or(Vec::new())) }

class_inherits -> Vec<Type<'input>> =
    _ ":" _ inherits:(type_def ++ ",") { inherits }

class_field -> FieldDef<'input> =
    enum_field / struct_field

enum_field -> FieldDef<'input> =
    _ name:id
    _ "(" types:(type_def ** ",") ")"
    { FieldDef::Enum(name, types) }

struct_field -> FieldDef<'input> =
    _ access:access_modifiers
    _ var:var_def
    { FieldDef::Field(access, var) }

// ####################################
// ## FUNCTIONS AND ACCESS MODIFIERS
// ####################################

func_def -> FuncDef<'input> =
    _ access:access_modifiers
    _ name:type_def
    _ "(" args:(var_def ** ",") ")"
    _ "->" ret:type_def
    _ guards:type_guards?
    _ body:block
    { FuncDef { access, name, ret, args, guards, body } }
    
var_def -> VarDef<'input> =
    _ name:id _ ty:var_type? _ value:var_value? { (name, ty, value) }

var_type -> Type<'input> =
    _ ":" _ ty:type_def { ty }

var_value -> Expr<'input> =
    _ "=" _ value:expr { value }

access_modifier -> &'input str =
    _ modifier:$("pub" / "const" / "static") _ { modifier }

access_modifiers -> i32 = 
    _ mods:access_modifier* 
    { mods.into_iter().fold(0, |acc, modifier| acc | access::from(modifier)) }

// ####################################
// ## TYPE DECLARATION
// ####################################

type_guards -> Vec<TypeGuard<'input>> =
    _ "where" _ guards:(type_guard ++ ",") { guards }

type_guard -> TypeGuard<'input> =
    _ ty:id _ ":" _ types:(type_def ++ "+") { (ty, types) }

type_def -> Type<'input> =
    type_array / type_generic / type_name

type_array -> Type<'input> =
    _ "[" ty:type_def "]"
    { Type::Array(Box::new(ty)) }

type_generic -> Type<'input> =
    _ name:id
    _ "<" templates:(type_def ++ ",") ">" 
    { Type::Generic(name, templates) }

type_name -> Type<'input> =
    _ "i32" _ { Type::Int32 }   /
    _ "i64" _ { Type::Int64 }   /
    _ "f32" _ { Type::Float32 } /
    _ "f64" _ { Type::Float64 } /
    _ ty:id _ { Type::Object(ty) }

// ####################################
// ## STATEMENTS
// ####################################

block -> Option<Vec<Expr<'input>>> =
    _ ";" _ { None }                                       /
    _ value:expr _ { Some(vec![value]) }                /
    _ "{" statements:statement* _ "}" { Some(statements) }

statement -> Expr<'input> =
    expr

if_statement -> ExprType<'input> =
    _ first:if_case<"if">
    _ elifs:if_case<"elif">*
    _ last:else_case? {
        let mut cases = elifs;
        cases.insert(1, first);
        If(cases, last)
    }

// ####################################
// ## STATEMENT HELPERS
// ####################################

else_case -> Vec<Expr<'input>> =
    _ "else" _ body:block
    { body.unwrap_or(Vec::new()) }

if_case<Keyword> =
    _ Keyword
    _ "(" cond:expr ")"
    _ body:block
    { (cond, body.unwrap_or(Vec::new())) }

// ####################################
// ## EXPRESSIONS
// ####################################

expr -> Expr<'input> =
    E<if_statement> / 
    E<call_expr> / E<index_expr> / binary_expr

call_expr -> ExprType<'input> =
    _ func:expr
    _ "(" args:(expr ** ",") ")"
    { Call(Box::new(func), args) }

index_expr -> ExprType<'input> =
    _ object:expr
    _ "[" index:expr "]"
    { Index(Box::new((object, index))) }

binary_expr -> Expr<'input> = #infix<primary_expr> {
    #R  lhs "=" rhs { ExprType::binop(Set, lhs, rhs) }
    #L  lhs "||" rhs { ExprType::binop(Or, lhs, rhs) }
    #L  lhs "&&" rhs { ExprType::binop(And, lhs, rhs) }
    #L  lhs "|" rhs { ExprType::binop(BitOr, lhs, rhs) }
    #L  lhs "^" rhs { ExprType::binop(Xor, lhs, rhs) }
    #L  lhs "&" rhs { ExprType::binop(BitAnd, lhs, rhs) }
    #L  lhs "==" rhs { ExprType::binop(Equ, lhs, rhs) }
        lhs "!=" rhs { ExprType::binop(Neq, lhs, rhs) }
    #L  lhs "<" rhs { ExprType::binop(Lt, lhs, rhs) }
        lhs ">" rhs { ExprType::binop(Gt, lhs, rhs) }
        lhs ">=" rhs { ExprType::binop(Lte, lhs, rhs) }
        lhs "<=" rhs { ExprType::binop(Gte, lhs, rhs) }
    #L  lhs "<<" rhs { ExprType::binop(Shl, lhs, rhs) }
        lhs ">>" rhs { ExprType::binop(Shr, lhs, rhs) }
    #L  lhs "+" rhs { ExprType::binop(Add, lhs, rhs) }
        lhs "-" rhs { ExprType::binop(Sub, lhs, rhs) }
    #L  lhs "*" rhs { ExprType::binop(Mul, lhs, rhs) }
        lhs "/" rhs { ExprType::binop(Div, lhs, rhs) }
        lhs "%" rhs { ExprType::binop(Mod, lhs, rhs) }
}

primary_expr -> Expr<'input> =
    E<literal>             /
    E<unary_expr>          /
    E<branch_expr>         /
    E<ternary_expr>        /
    _ "(" e:expr ")" _ { e }

unary_expr -> ExprType<'input> =
    _ "!" e:expr { Unop(Not, Box::new(e)) } /
    _ "-" e:expr { Unop(Sub, Box::new(e)) } /
    _ "~" e:expr { Unop(BitNot, Box::new(e)) }

branch_expr -> ExprType<'input> =
    _ "break"    { Break }    /
    _ "continue" { Continue } /
    _ "return" e:expr { Return(Box::new(e)) }

ternary_expr -> ExprType<'input> =
    _ cond:expr "?"
    _ if_true:expr ":"
    _ if_false:expr
    { If(vec![(cond, vec![if_true])], Some(vec![if_false])) }

// ####################################
// ## LITERAL EXPRESSIONS
// ####################################

literal -> ExprType<'input> =
    ident

ident -> ExprType<'input> =
    _ name:id _ { Id(name) }

// ####################################
// ## MISCELLANIOUS
// ####################################

id -> &'input str =
    $([a-zA-Z_$][a-zA-Z_$0-9]+)

_ = 
    #quiet<ignores*>

ignores =
    "/*" (!"*/" .)* "*/"   /
    "//" (!end_of_line .)* /
    #quiet<[ \n\r\t]+>

end_of_line =
    "\n" / "\r\n" / "\r" /
    "\u{2028}" / "\u{2029}"

E<Rule> =
    _ start:#position
    rule:Rule
    end:#position _
    { (rule, (start, end)) }